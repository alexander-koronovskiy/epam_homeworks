Исправления

задача 1
========

1. Чтобы не читать весь файл


Постарайся никогда не чи-
тать весь файл сразу в па-
мять, особенно когда это касается обработки файлов с последовательностями данных.
тут вполне мог быть файл на несколько гигабайт. Исправь пожалуйста код чтобы работал по мере чтения из файла.
2. ты вычитываешь посимвольно и приводишь к .lower(), и потом все равно соединяя в строку. можно было бы сразу прочитать все .read().lower()
3. слова могут разделяться любым из символов в string.whitespace. то же касается символов пунктуации (string.punctuation).
ты делаешь обычный .split(), этого может быть недостаточно если слова разделены, например, точкой.
4. то что вынес чтение файла в отдельную функцию - хорошо, но это заставляет тебя читать весь файл сразу же в память. Чтобы этого избежать, тебе надо
   - или использовать генератор-функцию (если знаешь что это такое) - и выдавать куски файла по частям.
   - или написать итератор - объект который будет почитывать файл по-чуть чуть
   - или если не знаешь ни про то ни про другое, можно было бы сохранить текущий файл куда-то в глобальную переменную и вычитывать по-чуть-чуть.

попытайся сформулировать как бы ты написал это русским языком, примерно в виде:

      прочитать слово до первого пробела или символа пунктуации
          обработать слово
      и уже реализовать эти операции отдельно.  В идеале код питона должен читаться как документ с требованиями.

      for text_element in read_next_element(filename):
          if text_element.type == punctuation:
              increment this punctuation symbol counter
          if text_element.type == word:
              do_something_else

      разница в читаемости (и понимаемости) огромная). Стремись к идеальной читаемости.


5. если ты обратишь внимание на сам файл, там всякие спецсимволы закодированы юникодовыми номерами. это файл в кодировке unicode-escape.
Если ты открываешь файл в текстовом режиме, то можно установить кодировку при чтении файла параметром encoding.

задача 2
===========
Теперь попробуй реализовать сам.

задача 3
============
Твой код можно было бы записать как return list(itertools.product(*args))
Теперь жду твоей реализации без использования .product()

задача 4
============
Наверное уже догадался. Реализуй сам, это несложно.

задача 5
=============
Функция должна работать не только на символах, а на любых последовательностях с уникальными элементами.
Например, custom_range([1,2,3,4,5], 2, 4) должно выдать [3, 4]
