задача 1
========
1. Постарайся никогда не чи-
тать весь файл сразу в па-
мять, особенно когда это касается обработки файлов с последовательностями данных.
тут вполне мог быть файл на несколько гигабайт. Исправь пожалуйста код чтобы работал по мере чтения из файла.
2. ты вычитываешь посимвольно и приводишь к .lower(), и потом все равно соединяя в строку. можно было бы сразу прочитать все .read().lower()
3. слова могут разделяться любым из символов в string.whitespace. то же касается символов пунктуации (string.punctuation).
ты делаешь обычный .split(), этого может быть недостаточно если слова разделены, например, точкой.
4. то что вынес чтение файла в отдельную функцию - хорошо, но это заставляет тебя читать весь файл сразу же в память. Чтобы этого избежать, тебе надо
   - или использовать генератор-функцию (если знаешь что это такое) - и выдавать куски файла по частям.
   - или написать итератор - объект который будет почитывать файл по-чуть чуть
   - или если не знаешь ни про то ни про другое, можно было бы сохранить текущий файл куда-то в глобальную переменную и вычитывать по-чуть-чуть.

попытайся сформулировать как бы ты написал это русским языком, примерно в виде:

      прочитать слово до первого пробела или символа пунктуации
          обработать слово
      и уже реализовать эти операции отдельно.  В идеале код питона должен читаться как документ с требованиями.

      for text_element in read_next_element(filename):
          if text_element.type == punctuation:
              increment this punctuation symbol counter
          if text_element.type == word:
              do_something_else

      разница в читаемости (и понимаемости) огромная). Стремись к идеальной читаемости.


5. если ты обратишь внимание на сам файл, там всякие спецсимволы закодированы юникодовыми номерами. это файл в кодировке unicode-escape.
Если ты открываешь файл в текстовом режиме, то можно установить кодировку при чтении файла параметром encoding.

задача 2
===========
Теперь попробуй реализовать сам.

задача 3
============
Твой код можно было бы записать как return list(itertools.product(*args))
Теперь жду твоей реализации без использования .product()

задача 4
============
Наверное уже догадался. Реализуй сам, это несложно.

задача 5
=============
Функция должна работать не только на символах, а на любых последовательностях с уникальными элементами.
Например, custom_range([1,2,3,4,5], 2, 4) должно выдать [3, 4]

def get_longest_diverse_words(file_path: str) -> List[str]:
    unique_map = {}
    s = get_file_content(file_path)
    words = s.split()

    for word in set(words):
        unique_map[word] = len(set(word))

    max_unique = sorted(unique_map.items(), key=lambda item: item[1], reverse=True)
    return [i[0] for i in max_unique[:10]]


def get_rarest_char(file_path: str) -> str:
    s = get_file_content(file_path)
    ch_map = {}

    for ch in s:
        if ch in ch_map:
            ch_map[ch] += 1
        else:
            ch_map[ch] = 1

    min_unique = sorted(ch_map.items(), key=lambda item: item[1])
    return min_unique[0][0]


def count_punctuation_chars(file_path: str) -> int:
    s = get_file_content(file_path)
    punctuation_count = 0

    for ch in s:
        if not (ch.isdigit() or ch.isalpha() or ch.isspace()):
            punctuation_count += 1

    return punctuation_count


isascii = lambda s: len(s) == len(s.encode())


def count_non_ascii_chars(file_path: str) -> int:
    s = get_file_content(file_path)
    non_ascii_count = 0
    for ch in s:
        if not isascii(ch):
            non_ascii_count += 1
    return non_ascii_count


def get_most_common_non_ascii_char(file_path: str) -> str:
    s = get_file_content(file_path)
    non_asciis = ""
    for ch in s:
        if not isascii(ch):
            non_asciis += ch
    return Counter(non_asciis).most_common()

import pytest
from task01.handler_file import count_punctuation_chars, get_rarest_char


@pytest.mark.parametrize(
    ["file", "expected_result"],
    [
        ("task01/data00.txt", "x"),
    ],
)
def test_rarest_char(file: str, expected_result: str):
    """
    test for handler_file.py get_rarest_char method
    """
    actual_result = get_rarest_char(file)
    assert actual_result == expected_result


@pytest.mark.parametrize(
    ["file", "expected_result"],
    [("task01/data00.txt", 7), ("task01/data.txt", 8280)],
)
def test_punctuation_chars(file: str, expected_result: int):
    """
    test for handler_file.py get_rarest_char method
    """
    actual_result = count_punctuation_chars(file)
    assert actual_result == expected_result


@pytest.mark.parametrize(
    ["file", "expected_result"],
    [("task01/data.txt", 2)],
)
def count_non_ascii_chars(file: str, expected_result: int):
    """
    test for handler_file.py count_non_ascii_chars method
    """
    actual_result = count_non_ascii_chars(file)
    assert actual_result == expected_result
